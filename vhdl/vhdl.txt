//Déclaration RAM_image

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity ram_image is
port (Clk : in std_logic;
        address : in integer;
        we : in std_logic;
        data_i : in std_logic_vector(7 downto 0);
        data_o : out std_logic_vector(7 downto 0)
     );
end ram_example;

architecture Behavioral of ram_image is

--Declaration of type and signal of a 256 element RAM
--with each element being 8 bit wide.
type ram_t is array (0 to 128*64) of std_logic_vector(7 downto 0);
signal ram : ram_t := (others => (others => '0'));

begin

--process for read and write operation.
PROCESS(Clk)
BEGIN
    if(rising_edge(Clk)) then
        if(we='1') then
            ram(address) <= data_i;
        end if;
        data_o <= ram(address);
    end if;
END PROCESS;

end Behavioral;



//Déclaration RAM_II

entity ram_II is
port (Clk : in std_logic;
        address : in integer;
        we : in std_logic;
        data_i : in std_logic_vector(31 downto 0);
        data_o : out std_logic_vector(31 downto 0)
     );
end ram_example;

architecture Behavioral of ram_II is

--Declaration of type and signal of a 256 element RAM
--with each element being 8 bit wide.
type ram_t is array (0 to 128*64) of std_logic_vector(31 downto 0);
signal ram : ram_t := (others => (others => '0'));

begin

--process for read and write operation.
PROCESS(Clk)
BEGIN
    if(rising_edge(Clk)) then
        if(we='1') then
            ram(address) <= data_i;
        end if;
        data_o <= ram(address);
    end if;
END PROCESS;

end Behavioral;


//Déclaration RAM_II²

entity ram_II_2 is
port (Clk : in std_logic;
        address : in integer;
        we : in std_logic;
        data_i : in std_logic_vector(39 downto 0);
        data_o : out std_logic_vector(39 downto 0)
     );
end ram_example;

architecture Behavioral of ram_II_2 is

--Declaration of type and signal of a 256 element RAM
--with each element being 8 bit wide.
type ram_t is array (0 to 128*64) of std_logic_vector(31 downto 0);
signal ram : ram_t := (others => (others => '0'));

begin

--process for read and write operation.
PROCESS(Clk)
BEGIN
    if(rising_edge(Clk)) then
        if(we='1') then
            ram(address) <= data_i;
        end if;
        data_o <= ram(address);
    end if;
END PROCESS;

end Behavioral;


//Déclaration RAM_image_ping

entity ram_image_ping is
port (Clk : in std_logic;
        address : in integer;
        we : in std_logic;
        data_i : in std_logic_vector(7 downto 0);
        data_o : out std_logic_vector(7 downto 0)
     );
end ram_example;

architecture Behavioral of ram_image_ping is

--Declaration of type and signal of a 256 element RAM
--with each element being 8 bit wide.
type ram_t is array (0 to 128*64) of std_logic_vector(7 downto 0);
signal ram : ram_t := (others => (others => '0'));

begin

--process for read and write operation.
PROCESS(Clk)
BEGIN
    if(rising_edge(Clk)) then
        if(we='1') then
            ram(address) <= data_i;
        end if;
        data_o <= ram(address);
    end if;
END PROCESS;

end Behavioral;


//Déclaration RAM_II_ping

entity ram_II_ping is
port (Clk : in std_logic;
        address : in integer;
        we : in std_logic;
        data_i : in std_logic_vector(31 downto 0);
        data_o : out std_logic_vector(31 downto 0)
     );
end ram_example;

architecture Behavioral of ram_II_ping is

--Declaration of type and signal of a 256 element RAM
--with each element being 8 bit wide.
type ram_t is array (0 to 128*64) of std_logic_vector(31 downto 0);
signal ram : ram_t := (others => (others => '0'));

begin

--process for read and write operation.
PROCESS(Clk)
BEGIN
    if(rising_edge(Clk)) then
        if(we='1') then
            ram(address) <= data_i;
        end if;
        data_o <= ram(address);
    end if;
END PROCESS;

end Behavioral;



//Déclaration RAM_II

entity ram_II_2_ping is
port (Clk : in std_logic;
        address : in integer;
        we : in std_logic;
        data_i : in std_logic_vector(39 downto 0);
        data_o : out std_logic_vector(39 downto 0)
     );
end ram_example;

architecture Behavioral of ram_II_2_ping is

--Declaration of type and signal of a 256 element RAM
--with each element being 8 bit wide.
type ram_t is array (0 to 128*64) of std_logic_vector(31 downto 0);
signal ram : ram_t := (others => (others => '0'));

begin

--process for read and write operation.
PROCESS(Clk)
BEGIN
    if(rising_edge(Clk)) then
        if(we='1') then
            ram(address) <= data_i;
        end if;
        data_o <= ram(address);
    end if;
END PROCESS;

end Behavioral;












   
//Machine à état




library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity fsm is
    port(
        CLK                     : in  std_logic;
        RESET                   : in  std_logic;
        ) ;
end fsm;

architecture A of FSM is
    type   STATE is (Wait0, Req_s1, Ack_stage2, Req_f3, Req_r4, Req_pts5, Eval_f6, Eval_s7);
    signal Current_State, Next_State   : STATE;
    signal access_count, access_count_next : std_logic_vector(3 downto 0);
    signal if, if_next : std_logic_vector(11 downto 0);
    signal is, is_next : std_logic_vector(5 downto 0);

begin

    P_STATE : process(clk)
    begin
     if rising_edge(clk) then
      if (RESET = '1') then
      current_state <= Wait0;
       
      else
                access_count <= access_count_next;
		if <= if_next;
		is <= is_next;
      		Current_State <= Next_State;
     end if;
    end if;
   end process P_STATE;

   



        P_FSM : process(current_state,Tap_Number,Tap_Number_3,ADC_eoc)
    begin
             
     case current_state is
       when S0 =>
              
       when S1 =>
                
        when S11 =>
                
        when S2 =>
                
        when S3 =>
                
        when S4 =>
               
        when others => next_state <= S0;
        end case;
   end process P_FSM;



//Trdauction du c vers vhdl
/* calcul l'intégrale sur un carre de coin x, y et de largeur (tx,ty) */
4 signaux de valeurs récupérer depuis ram_img
    FUNCTION img_rect(L1 : IN std_logic_vector(7 downto 0); 
        L2 : IN std_logic_vector(7 downto 0);
	L3 : IN std_logic_vector(7 downto 0);
	L4 : IN std_logic_vector(7 downto 0)
    ) RETURN integer;

BEGIN
	RETURN L4-L3-L2+L1;
END img_rect;




//Process d'évaluation du stage
il faut la valeur des sommes des features
il faut la valeur du seuil du stage
 FUNCTION eval_Stage(sum_s: INTEGER
    ) RETURN Boolean;

BEGIN
	RETURN (sum_s < seuil);
END eval_Stage;
   









//Evaluate feature
il faut l'ancienne valeur du feature prev_f
il faut les v0 et v1
il faut la valeur totale de l'image intégrale carrée sur le pixel  =sq_mean
il faut la surface du pixel = area
il faut les 4 valeurs des rectangles = R1,R2,R3,R4
il faut les poids des 4 rectangles = P1,P2,P3,P4;
il faut le seuil du feature = seuil
use IEEE.MATH_REAL.ALL;

 FUNCTION eval_Feature(prev_f: INTEGER;
			v0: INTEGER;
			v1: INTEGER;
			sq_mean: INTEGER;
			mean: INTEGER;
			R1: INTEGER;
			R2: INTEGER;
			R3: INTEGER;
			R4: INTEGER;
			P1: INTEGER;
			P2: INTEGER;
			P3: INTEGER;
			P4: INTEGER;
			seuil: INTEGER;
    ) RETURN integer;
variable variance_sq: INTEGER;
variable variance: INTEGER; //on n' a pas besoin d'être hyper précis je pense
variable sum_f: INTEGER;
variable test: BOOLEAN;
variable alpha: BOOLEAN;

BEGIN

	variance_sq=sq_mean*area-mean*mean; 
    	variance=sqrt(variance_sq);
    
    	sum_f = P1*R1+P2*R2+P3*R3+P4*R4;
 
      	float t = mult_fixe( mult_fixe(seuil*seuil)*variance_sq);
      	//   Test le feature
      	test = (sum_f*sum_f) >= t;
      	if (sum_f>= 0 ) then
        {
          	if (th>=0) then
            		alpha= test ? 1 : 0;
          	else
            		alpha=1;
		end if;
        }
      	else
        {
          	if (th>0) then
            		alpha= 0;
         	else
            		alpha= (!test) ? 1 : 0;
		end if;
        }
	end if;
	if(alpha=FALSE) then 
		RETURN prev_f+v0;
	else 
		RETURN prev_f+v1;
	end if;

END eval_Feature;

    

